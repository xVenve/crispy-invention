# -*- coding: utf-8 -*-
"""RNA_P2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Fpws9D2rNBbBhlNpoN5OHHlirrphutw_

# Librerias
"""

import tensorflow as tf
import numpy as np
import pandas as pd
import os
from keras.models import Sequential
from keras.layers import Dense
from tensorflow.keras.utils import to_categorical
from sklearn.metrics import confusion_matrix, classification_report

"""# Preparación datos

Cargar los datos
"""

train_set = pd.read_csv('/content/training.csv', header = 'infer', delimiter=',')
test_set = pd.read_csv('/content/test.csv', header = 'infer',delimiter=',')
# SELECCION DE LA SALIDA
y_train = train_set.iloc[:,-1:]
X_train = train_set.iloc[: , :-1]
y_test = test_set.iloc[:,-1:]
X_test = test_set.iloc[: , :-1]

"""Codificar la salida"""

# CONVERTIR TARGET A CATEGORICAL
from sklearn.preprocessing import LabelBinarizer
encoder = LabelBinarizer()
y_train_transformed = encoder.fit_transform(y_train)
y_test_transformed = encoder.fit_transform(y_test)
print(y_train[:11])
print(y_train_transformed[:11])

"""Ver la estructura de los datos"""

# COMPROBAR DIMENSIONES DE LOS DATOS
print(X_train.shape)
print(y_train.shape)
print(y_train_transformed.shape)
print(X_test.shape)
print(y_test.shape)
print(y_test_transformed.shape)
#obtener dim de la entrada y número de salidas
input_shape = (X_train.shape [1] ,) # (18, )
num_clases = y_train_transformed.shape [1] # 4

"""# Modelo final"""

# Construir y entrenar el modelo definitivo
num_neuronasc1=50
num_neuronasc2=20
lr=0.3
epochs=341
#definir modelo
final_model=Sequential()
final_model.add(Dense(num_neuronasc1,input_shape=input_shape,activation='sigmoid'))
final_model.add(Dense(num_neuronasc2,activation='sigmoid'))
final_model.add(Dense(num_clases,activation='softmax'))

final_model.summary()

# CONFIGURAR MODELO Y ENTRENAMIENTO (TRAINING 100%)
final_model.compile(loss ='mean_squared_error', 
                    optimizer = tf.keras.optimizers.SGD(learning_rate=lr, momentum=0),
                    metrics=['accuracy','mse'])
history_final_model = final_model.fit(X_train, y_train_transformed, epochs=epochs,
                                     batch_size=1, verbose=1, validation_split=0, shuffle=False)

# EVALUAR MODELO DEFINITIVO 
test_results = final_model.evaluate(X_test, y_test_transformed, verbose=1)
print ( f'Test results - Loss: {test_results[0]} - Accuracy: {test_results[1]}')

## plots de evolución de loss y accuracy
from matplotlib import pyplot as plt
plt.plot(history_final_model.history['accuracy'])
plt.title('model accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()
plt.plot(history_final_model.history['loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

# predicciones en bruto
raw_testPred = final_model.predict(X_test)
# predicción de los 5 primeros patrones de test: 5 vectores con valores reales
print(raw_testPred[:5])

# predicciones de la clase
testPred = np.argmax(raw_testPred, axis=1)
# transformar el num de col en la etiqueta
class_testPred = encoder.classes_[testPred]
print(testPred[:5])
print(class_testPred[:5])

# Confusion Matrix
cm = confusion_matrix(y_test, class_testPred)
print(cm)

print('Classification Report')
print(classification_report(y_test, class_testPred))

!mkdir salida

# evaluacion del modelo final (loss y accuracy)
np.savetxt('/content/salida/evaluacion.txt', test_results, newline='\t')

# guardar matriz de confusion
np.savetxt('/content/salida/matrizConf.txt', cm, fmt='%-3d')

# guarda el modelo completo
final_model.save('/content/salida/modelo.h5')
# guarda solo pesos
final_model.save_weights('/content/salida/pesos.h5')